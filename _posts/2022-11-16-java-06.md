---
layout: post
categories: Java
title: "[JAVA] OOP"
date: 2022-11-16
permalink: /java/oop
tags:
  - java
---
* content
{: toc}


<!--more-->


# 객체

프로그램의 동작 주체가 되는 요소, 모든 객체는 상태와 동작을 가짐

## 객체 지향

객체를 통해 코드를 구성하는 방법론, 객체의 상호작용을 코드로 나타냄

> 클래스 = 필드(field) + 메소드(method)
> 객체 설계도 = 객체 속성(변수) + 객체 행동(명령문)
(명령문)


- **인스턴스** : 해당 클래스 타입의 객체 (여러개 생성 가능)

### 필드

클래스 변수와 인스턴스 변수는 별도로 초기화하지 않으면 자동 초기화되며, 지역변수는 별도로 초기화 해줘야 함

|변수|저장 메모리|사용 방법|
|---|---|---|
|클래스 변수(static variable)|메소드 영역|클래스이름.변수이름|
|인스턴스 변수(instance variable)|힙 영역|인스턴스이름.변수이름|
|지역변수(local variable)|스택 영역|변수이름|

### 메소드

중복되는 코드의 반복적인 프로그래밍을 피하기 위해 사용
하나의 메소드가 하나의 기능만을 수행하도록 작성하는 것이 기본적

- 클래스 메소드(static method)
- 인스턴스 메소드(instance method)

```java
객체참조변수이름.메소드이름();                  
// 매개변수가 없는 메소드의 호출

객체참조변수이름.메소드이름(인수1, 인수2, ...); 
// 매개변수가 있는 메소드의 호출
```

- 메소드 오버로딩

### 생성자

생성된 객체의 필드를 초기화해주는 메소드
- 생성자를 정의하지 않아도 **자바 컴파일러가 기본 생성자를 제공함**
- 생성자는 반환값이 없지만, 반환 타입을 void형으로 선언하지 않는다.
- 생성자는 초기화를 위한 데이터를 인수로 전달받을 수 있다.
- 객체를 초기화하는 방법이 여러 개 존재할 경우에는 하나의 클래스가 여러 개의 생성자를 가질 수 있다. 
  (즉, 생성자도 하나의 메소드이므로, 메소드 오버로딩 가능)
    
```java
class Car {
		//생성자 선언
		Car(String modelName, int modelYear, String color, int maxSpeeds) {
			this.modelName = modelName;
			this.modelYear = modelYear;
			this.color = color;
			this.maxSpeed = maxSpeed;
			this.currentSpeed = 0;
		}
		

	Car() {
			this("소나타", 2012, "검정색", 160); // 다른 생성자를 호출함.
													//반드시 해당 생성자의 첫 줄에서만 호출 가능
		}

	public String getModel() {
			return this.modelYear + "년식 " + this.modelName + " " + this.color;
	}
```
    
- `this 참조변수` : 생성자의 매개변수 이름과 인스턴스 변수의 이름이 같을 경우에는 인스턴스 변수 앞에 this키워드를 붙여 구분해야 함
    
- `this() 메소드` : 생성자 내부에서만 사용할 수 있으며, 같은 클래스의 다른 생성자를 호출할 때 사용함
    

```java
public class Method05 {

    public static void main(String[] args) {
			Car tcpCar = new Car();
			System.out.println(tcpCar.getModel())
			//2012년식 소나타 검정색

			Car myCar = new Car("아반떼", 2016, "흰색", 200);
			System.out.println(myCar .getModel())	
			//2016년식 아반떼 흰색
		}

}
```

---

## 객체 지향의 장점과 단점
👍 코드 재사용성
👍 간편한 유지보수(연관 객체만 수정)
👍 업무 분장 및 도식화가 용이해 큰 규모 프로그래밍에 유리
👎 각 객체의 의존관계 복잡도에 의해 비교적 느린 속도
👎 높은 설계 역량 요구
	        
- 메소드 오버로딩과 오버라이딩
    
    메소드 오버로딩은 서로 다른 시그니처를 갖는 여러 메소드를 하나의 이름으로 정의하는 것인 한편 메소드 오버라이딩은 상속 관계에 있는 부모 클래스에서 이미 정의된 메소드를 자식 클래스에서 같은 시그니쳐를 갖는 메소드로 다시 정의하는 것을 의미
    

---

# 객체 지향 설계 원칙

## Single Responsibility Principle

단일 책임 원칙

하나의 클래스는 하나의 역할만 해야 한다.

## Open - Close Principle

개방-폐쇄 원칙

확장 (상속)에는 열려있고, 수정에는 닫혀 있어야 한다.

## Liskov Substitution Principle

리스코프 치환 원칙

자식이 부모의 자리에 항상 교체될 수 있어야 한다.

## Interface Segregation Principle

인터페이스 분리 원칙

객체는 자신이 호출하지 않는 메소드에 의존하지 않아야 한다.

## Dependency Inversion Property

의존성 역전 원칙

상위 모듈이 하위 모듈에 의존하지 않아야 한다.

---

# 추상화

객체의 공통적인 속성과 기능을 추출하여 정의 하는것 ⇒ **역할과 구현의 분리**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/aa2f7073-8c54-460e-89b0-cf8aecdea954/Untitled.png)

---

추상클래스와 인터페이스의 차이

`extends`

- 추상 클래스는 하나 이상의 추상 메서드를 포함한 클래스를 의미하며, 생성자 및 일반 메서드도 포함할 수 있다.
- 추상 클래스는 단일 상속만 허용된다.

`implements`

- 인터페이스는 추상 메서드와 상수만을 포함한다.
- 인터페이스는 클래스에 다중 구현 및 인터페이스 끼리 다중 상속이 가능하다.
- 추상 메서드는 함수 선언만 되어있고 구현부가 없는 메서드를 의미한다.

---

# 다형성

**어떤 객체의 속성이나 기능이 그 맥락에 따라 다른 역할을 수행할 수 있는 객체 지향의 특성**을 의미

⇒ 한 타입의 참조변수를 통해 여러 타입의 객체를 참조할 수 있도록 만든 것

- 대표적인 예시로 메서드 오버로딩과 오버라이딩이 해당
    
    - 오버라이딩 : 같은 이름의 메서드가 상황에 따라 다른 역할을 수행하는 것
    - 오버로딩 : 하나의 클래스 내에서 같은 이름의 메서드를 여러 개 중복하여 정의하는 것
    
    ### 구현 예시
    
  
    ⇒ 각 클래스에 직접 접근하지 못하도록 인터페이스로 감싸주어, 코드의 중복성이 사라지고 외부로부터 데이터 보호가 가능해짐
    

---

# 상속

**기존의 클래스를 재활용하여 새로운 클래스를 작성하는 자바의 문법 요소를 의미**

- 상위 클래스로부터 확장된 여러 개의 하위 클래스들이 모두 상위 클래스의 속성과 기능들을 간편하게 사용할 수 있음
- 모든 구체적인 내용들을 상위 클래스에 정의해두고 하위 클래스에서는 그것을 단순히 가져다가 재사용할 수 있음

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fb1c941f-7d40-47fd-85fb-0937bea2610c/Untitled.png)